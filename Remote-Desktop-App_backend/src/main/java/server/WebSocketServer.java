package main.java.server;

import java.io.*;
import java.net.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collectors;
import main.java.capture.ScreenCapturer;
import main.java.chat.ChatManager;
import main.java.filetransfer.FileTransferManager;
import main.java.filetransfer.FileInfo;
import main.java.filetransfer.FileTransferSession;

public class WebSocketServer {
    private static final int WEBSOCKET_PORT = 8081;
    private ServerSocket serverSocket;
    private volatile boolean isRunning = false;
    private List<WebSocketClientHandler> clients = new CopyOnWriteArrayList<>();
    private ControlQueue controlQueue;
    private ScreenCapturer screenCapturer;
    private ScheduledExecutorService screenCaptureExecutor;
    private ScheduledExecutorService heartbeatExecutor;
    private ExecutorService clientExecutor;
    private AuthenticationManager authManager;
    private Scanner consoleScanner;
    private ChatManager chatManager;
    private FileTransferManager fileTransferManager;

    // Map pour stocker les noms d'affichage
    private Map<String, String> clientDisplayNames = new ConcurrentHashMap<>();

    // Optimisations
    private AtomicLong frameCounter = new AtomicLong(0);
    private volatile byte[] lastScreenData = null;
    private final Object screenDataLock = new Object();
    private long lastBroadcastTime = 0;
    private static final long MIN_BROADCAST_INTERVAL = 100;

    public WebSocketServer() {
        this.controlQueue = new ControlQueue();
        this.controlQueue.setServer(this); // ‚úÖ NOUVEAU : R√©f√©rence pour notifications
        this.screenCapturer = new ScreenCapturer();
        this.screenCaptureExecutor = Executors.newSingleThreadScheduledExecutor();
        this.heartbeatExecutor = Executors.newSingleThreadScheduledExecutor();
        this.clientExecutor = Executors.newCachedThreadPool();
        this.authManager = new AuthenticationManager();
        this.consoleScanner = new Scanner(System.in);
        this.chatManager = new ChatManager();
        this.fileTransferManager = new FileTransferManager();
    }

    public void start() throws IOException {
        serverSocket = new ServerSocket(WEBSOCKET_PORT);
        isRunning = true;

        printStartupInfo();
        startScreenCapture();
        startHeartbeatService();
        startConsoleHandler();

        System.out.println("üü¢ Serveur WebSocket pr√™t sur le port " + WEBSOCKET_PORT);
        System.out.println("üåê Frontend React : http://localhost:3000");
        System.out.println("üí¨ Chat en direct avec noms personnalis√©s activ√©");
        System.out.println("üìÅ Transfert de fichiers activ√©");
        System.out.println("üë• Liste d'utilisateurs en temps r√©el activ√©e");
        System.out.println("üîë G√©n√©ration automatique de mots de passe activ√©e");
        System.out.println("‚è±Ô∏è Contr√¥le limit√©: 4 minutes | Inactivit√©: 1 minute\n");

        while (isRunning) {
            try {
                Socket clientSocket = serverSocket.accept();
                String clientIP = clientSocket.getInetAddress().getHostAddress();

                WebSocketClientHandler handler = new WebSocketClientHandler(clientSocket, this, clientIP);
                clients.add(handler);
                clientExecutor.submit(handler);

                System.out.println("üîó Nouvelle connexion WebSocket de: " + clientIP);
            } catch (IOException e) {
                if (isRunning) {
                    System.err.println("‚ùå Erreur lors de l'acceptation du client: " + e.getMessage());
                }
            }
        }
    }

    // ‚úÖ NOUVELLE M√âTHODE : Notifier changement de contr√¥le
    public void notifyControlChange(String clientId, boolean granted) {
        for (WebSocketClientHandler client : clients) {
            if (client.getClientId().equals(clientId)) {
                if (granted) {
                    client.sendMessage("CONTROL_GRANTED");
                    System.out.println("‚úÖ Notification contr√¥le accord√© envoy√©e √†: " + clientId);
                } else {
                    client.sendMessage("CONTROL_RELEASED");
                    System.out.println("‚ùå Notification contr√¥le lib√©r√© envoy√©e √†: " + clientId);
                }
                break;
            }
        }

        // Diffuser la liste des utilisateurs mise √† jour
        broadcastUserList();
    }

    // ‚úÖ NOUVELLE M√âTHODE : Notifier position dans la file
    public void notifyQueuePosition(String clientId, int position) {
        for (WebSocketClientHandler client : clients) {
            if (client.getClientId().equals(clientId)) {
                client.sendMessage("QUEUE_POSITION:" + position);
                System.out.println("üìç Position " + position + " envoy√©e √†: " + clientId);
                break;
            }
        }
    }

    // ‚úÖ NOUVELLE M√âTHODE : Diffuser la liste des utilisateurs connect√©s
    public void broadcastUserList() {
        List<WebSocketClientHandler> authenticatedClients = getAuthenticatedClients();

        // Cr√©er la liste JSON des utilisateurs
        StringBuilder userListJson = new StringBuilder("[");

        for (int i = 0; i < authenticatedClients.size(); i++) {
            WebSocketClientHandler client = authenticatedClients.get(i);
            String clientId = client.getClientId();
            String displayName = clientDisplayNames.getOrDefault(clientId, "User-" + clientId.substring(0, 4));
            boolean hasControl = controlQueue.hasControl(clientId);
            String clientIP = client.getClientIP();

            userListJson.append("{")
                    .append("\"id\":\"").append(clientId).append("\",")
                    .append("\"displayName\":\"").append(displayName).append("\",")
                    .append("\"hasControl\":").append(hasControl).append(",")
                    .append("\"ip\":\"").append(clientIP).append("\",")
                    .append("\"status\":\"").append(hasControl ? "Contr√¥le" : "Spectateur").append("\"")
                    .append("}");

            if (i < authenticatedClients.size() - 1) {
                userListJson.append(",");
            }
        }

        userListJson.append("]");

        // Diffuser la liste √† tous les clients authentifi√©s
        String message = "USER_LIST:" + userListJson.toString();
        authenticatedClients.parallelStream().forEach(client -> {
            try {
                client.sendMessage(message);
            } catch (Exception e) {
                // Ignorer silencieusement
            }
        });

        System.out.println("üìã Liste des utilisateurs diffus√©e: " + authenticatedClients.size() + " clients");
    }

    // ‚úÖ NOUVELLE M√âTHODE : Envoyer la liste √† un client sp√©cifique
    public void sendUserListToClient(WebSocketClientHandler client) {
        List<WebSocketClientHandler> authenticatedClients = getAuthenticatedClients();

        StringBuilder userListJson = new StringBuilder("[");

        for (int i = 0; i < authenticatedClients.size(); i++) {
            WebSocketClientHandler authClient = authenticatedClients.get(i);
            String clientId = authClient.getClientId();
            String displayName = clientDisplayNames.getOrDefault(clientId, "User-" + clientId.substring(0, 4));
            boolean hasControl = controlQueue.hasControl(clientId);
            String clientIP = authClient.getClientIP();

            userListJson.append("{")
                    .append("\"id\":\"").append(clientId).append("\",")
                    .append("\"displayName\":\"").append(displayName).append("\",")
                    .append("\"hasControl\":").append(hasControl).append(",")
                    .append("\"ip\":\"").append(clientIP).append("\",")
                    .append("\"status\":\"").append(hasControl ? "Contr√¥le" : "Spectateur").append("\"")
                    .append("}");

            if (i < authenticatedClients.size() - 1) {
                userListJson.append(",");
            }
        }

        userListJson.append("]");

        try {
            client.sendMessage("USER_LIST:" + userListJson.toString());
        } catch (Exception e) {
            System.err.println("Erreur envoi liste utilisateurs: " + e.getMessage());
        }
    }

    // ‚úÖ GETTER : Pour acc√©der √† ControlQueue
    public ControlQueue getControlQueue() {
        return controlQueue;
    }

    // M√©thodes pour la gestion des fichiers
    public String startFileUpload(String clientId, String fileName, long fileSize, String fileType) {
        String sessionId = fileTransferManager.startFileUpload(clientId, fileName, fileSize, fileType);
        if (sessionId != null) {
            String senderName = clientDisplayNames.getOrDefault(clientId, "User-" + clientId.substring(0, 4));
            System.out.println("üìÅ " + senderName + " commence l'upload de: " + fileName);
        }
        return sessionId;
    }

    public boolean receiveFileChunk(String sessionId, int chunkIndex, byte[] data) {
        boolean success = fileTransferManager.receiveFileChunk(sessionId, chunkIndex, data);
        if (success) {
            FileTransferSession session = fileTransferManager.getSession(sessionId);
            if (session != null && session.isComplete()) {
                broadcastFileAvailable(session.getFileName());
            }
        }
        return success;
    }

    public void sendFileList(WebSocketClientHandler client) {
        List<FileInfo> files = fileTransferManager.getAvailableFiles();
        StringBuilder json = new StringBuilder("[");
        for (int i = 0; i < files.size(); i++) {
            json.append(files.get(i).toJson());
            if (i < files.size() - 1) json.append(",");
        }
        json.append("]");

        try {
            client.sendMessage("FILE_LIST:" + json.toString());
        } catch (Exception e) {
            System.err.println("Erreur envoi liste fichiers: " + e.getMessage());
        }
    }

    public void startFileDownload(String clientId, String fileName, WebSocketClientHandler client) {
        FileTransferSession session = fileTransferManager.startFileDownload(clientId, fileName);
        if (session != null) {
            try {
                String sessionInfo = String.format(
                        "{\"sessionId\":\"%s\",\"fileName\":\"%s\",\"fileSize\":%d,\"totalChunks\":%d}",
                        session.getSessionId(), session.getFileName(),
                        session.getFileSize(), session.getTotalChunks()
                );
                client.sendMessage("DOWNLOAD_START:" + sessionInfo);
                String senderName = clientDisplayNames.getOrDefault(clientId, "User-" + clientId.substring(0, 4));
                System.out.println("üì• " + senderName + " t√©l√©charge: " + fileName);
            } catch (Exception e) {
                System.err.println("Erreur d√©marrage download: " + e.getMessage());
            }
        }
    }

    public void sendFileChunk(String sessionId, int chunkIndex, WebSocketClientHandler client) {
        byte[] chunkData = fileTransferManager.readFileChunk(sessionId, chunkIndex);
        if (chunkData != null) {
            try {
                String base64Data = Base64.getEncoder().encodeToString(chunkData);
                String message = String.format("FILE_CHUNK:%s:%d:%s", sessionId, chunkIndex, base64Data);
                client.sendMessage(message);
            } catch (Exception e) {
                System.err.println("Erreur envoi chunk: " + e.getMessage());
            }
        }
    }

    private void broadcastFileAvailable(String fileName) {
        List<WebSocketClientHandler> authenticatedClients = getAuthenticatedClients();
        String message = "FILE_AVAILABLE:" + fileName;

        authenticatedClients.parallelStream().forEach(client -> {
            try {
                client.sendMessage(message);
            } catch (Exception e) {
                // Ignorer silencieusement
            }
        });

        chatManager.addSystemMessage("üìÅ Nouveau fichier disponible: " + fileName);
        main.java.chat.ChatMessage chatMessage = new main.java.chat.ChatMessage(
                "system", "Syst√®me", "üìÅ Nouveau fichier disponible: " + fileName, "system"
        );
        chatManager.broadcastMessage(chatMessage, authenticatedClients);
    }

    // M√©thodes pour le chat avec noms personnalis√©s
    public void handleChatMessage(String senderId, String message) {
        String senderName = clientDisplayNames.getOrDefault(senderId, "User-" + senderId.substring(0, 4));

        chatManager.addMessage(senderId, senderName, message);
        List<WebSocketClientHandler> authenticatedClients = getAuthenticatedClients();
        main.java.chat.ChatMessage chatMessage = new main.java.chat.ChatMessage(senderId, senderName, message, "text");
        chatManager.broadcastMessage(chatMessage, authenticatedClients);
    }

    public void sendChatHistoryToClient(WebSocketClientHandler client) {
        chatManager.broadcastChatHistory(client);
    }

    // ‚úÖ MODIFICATION : Notification d'arriv√©e avec diffusion de liste
    public void notifyUserJoined(String clientId, String displayName) {
        List<WebSocketClientHandler> authenticatedClients = getAuthenticatedClients();
        chatManager.notifyUserJoined(displayName, authenticatedClients);

        // ‚úÖ NOUVEAU : Diffuser la liste mise √† jour
        broadcastUserList();
    }

    // ‚úÖ MODIFICATION : Notification de d√©part avec diffusion de liste
    public void notifyUserLeft(String clientId) {
        String displayName = clientDisplayNames.getOrDefault(clientId, "User-" + clientId.substring(0, 4));
        List<WebSocketClientHandler> authenticatedClients = getAuthenticatedClients();
        chatManager.notifyUserLeft(displayName, authenticatedClients);
        clientDisplayNames.remove(clientId);

        // ‚úÖ NOUVEAU : Diffuser la liste mise √† jour
        broadcastUserList();
    }

    private void startScreenCapture() {
        System.out.println("üìπ Capture optimis√©e d√©marr√©e...");

        screenCaptureExecutor.scheduleAtFixedRate(() -> {
            try {
                List<WebSocketClientHandler> authenticatedClients = getAuthenticatedClients();

                if (!authenticatedClients.isEmpty()) {
                    long currentTime = System.currentTimeMillis();

                    if (currentTime - lastBroadcastTime < MIN_BROADCAST_INTERVAL) {
                        return;
                    }

                    synchronized (screenDataLock) {
                        byte[] screenData = screenCapturer.captureScreen();

                        if (screenData != null && !Arrays.equals(screenData, lastScreenData)) {
                            lastScreenData = screenData.clone();
                            long frameId = frameCounter.incrementAndGet();

                            broadcastScreenDataFast(screenData, frameId, authenticatedClients);
                            lastBroadcastTime = currentTime;
                        }
                    }
                }
            } catch (Exception e) {
                // Ignorer les erreurs
            }
        }, 0, MIN_BROADCAST_INTERVAL, TimeUnit.MILLISECONDS);
    }

    public void broadcastScreenDataFast(byte[] screenData, long frameId, List<WebSocketClientHandler> targetClients) {
        if (screenData == null || targetClients.isEmpty()) return;

        String base64Image = Base64.getEncoder().encodeToString(screenData);
        String message = "SCREEN_DATA:" + frameId + ":" + base64Image;

        targetClients.parallelStream().forEach(client -> {
            try {
                client.sendMessageFast(message);
            } catch (Exception e) {
                // Ignorer silencieusement
            }
        });
    }

    private void startHeartbeatService() {
        heartbeatExecutor.scheduleAtFixedRate(() -> {
            clients.removeIf(client -> !client.isConnected());
        }, 30, 30, TimeUnit.SECONDS);
    }

    private void startConsoleHandler() {
        Thread consoleThread = new Thread(() -> {
            while (isRunning) {
                try {
                    String command = consoleScanner.nextLine().trim();
                    handleConsoleCommand(command);
                } catch (Exception e) {
                    // Ignorer
                }
            }
        });
        consoleThread.setDaemon(true);
        consoleThread.start();
    }

    // ‚úÖ CORRECTION : Fermeture de session am√©lior√©e
    public void endClientSession(String clientId, WebSocketClientHandler clientHandler) {
        AuthenticationManager.AuthenticatedClient client = authManager.getAuthenticatedClient(clientId);
        if (client != null) {
            String displayName = clientDisplayNames.getOrDefault(clientId, "User-" + clientId.substring(0, 4));

            // ‚úÖ CORRECTION : Lib√©rer le contr√¥le avant la fermeture
            if (controlQueue.hasControl(clientId)) {
                controlQueue.releaseControl(clientId);
                System.out.println("üéÆ Contr√¥le lib√©r√© pour: " + displayName);
            }

            // Envoyer confirmation de fermeture au client
            try {
                clientHandler.sendMessage("SESSION_ENDED_CONFIRMATION");

                // Attendre que le message soit envoy√©
                Thread.sleep(1000);

            } catch (Exception e) {
                System.err.println("Erreur envoi confirmation: " + e.getMessage());
            }

            // ‚úÖ CORRECTION : Nettoyer d'abord, d√©connecter ensuite
            authManager.removeClient(clientId);
            clientDisplayNames.remove(clientId);

            // Notifier les autres clients AVANT la d√©connexion
            notifyUserLeft(clientId);

            // D√©connecter le client en dernier
            clientHandler.disconnect();

            System.out.println("üîö Session ferm√©e par le client: " + displayName + " (" + clientId + ")");
        }
    }

    private void handleConsoleCommand(String command) {
        String[] parts = command.split(" ");
        String cmd = parts[0].toLowerCase();

        switch (cmd) {
            case "list":
                authManager.listPendingConnections();
                break;
            case "accept":
                if (parts.length > 1) {
                    authManager.acceptConnection(parts[1]);
                }
                break;
            case "deny":
                if (parts.length > 1) {
                    authManager.denyConnection(parts[1]);
                }
                break;
            case "passwords":
                authManager.listActivePasswords();
                break;
            case "getpassword":
                if (parts.length > 1) {
                    String clientId = parts[1];
                    String password = authManager.getClientPassword(clientId);
                    if (password != null) {
                        System.out.println("üîë Mot de passe pour " + clientId + ": " + password);
                    } else {
                        System.out.println("‚ùå Aucun mot de passe trouv√© pour " + clientId);
                    }
                } else {
                    System.out.println("Usage: getpassword <clientId>");
                }
                break;
            case "regenerate":
                if (parts.length > 1) {
                    String clientId = parts[1];
                    String newPassword = authManager.regeneratePasswordForClient(clientId);
                    System.out.println("üîÑ Nouveau mot de passe pour " + clientId + ": " + newPassword);
                } else {
                    System.out.println("Usage: regenerate <clientId>");
                }
                break;
            case "closesession":
                if (parts.length > 1) {
                    String clientId = parts[1];
                    WebSocketClientHandler targetClient = null;

                    for (WebSocketClientHandler client : clients) {
                        if (client.getClientId().equals(clientId)) {
                            targetClient = client;
                            break;
                        }
                    }

                    if (targetClient != null) {
                        boolean closed = authManager.closeClientSession(clientId, targetClient);
                        if (closed) {
                            System.out.println("‚úÖ Session ferm√©e pour le client: " + clientId);
                        } else {
                            System.out.println("‚ùå Impossible de fermer la session pour: " + clientId);
                        }
                    } else {
                        System.out.println("‚ùå Client non trouv√©: " + clientId);
                    }
                } else {
                    System.out.println("Usage: closesession <clientId>");
                }
                break;
            // ‚úÖ NOUVELLES COMMANDES : Gestion de la concurrence
            case "status":
                controlQueue.printConcurrencyStatus();
                break;
            case "forcerelease":
                String adminId = "admin";
                boolean released = controlQueue.forceRelease(adminId);
                if (released) {
                    System.out.println("‚úÖ Contr√¥le lib√©r√© de force");
                } else {
                    System.out.println("‚ùå Aucun contr√¥leur actuel");
                }
                break;
            case "queue":
                String[] waiting = controlQueue.getWaitingClients();
                System.out.println("üìã File d'attente (" + waiting.length + " clients):");
                for (int i = 0; i < waiting.length; i++) {
                    String displayName = clientDisplayNames.getOrDefault(waiting[i], waiting[i]);
                    System.out.println("   " + (i+1) + ". " + displayName + " (" + waiting[i] + ")");
                }
                break;
            case "chat":
                if (parts.length > 1) {
                    String adminMessage = String.join(" ", Arrays.copyOfRange(parts, 1, parts.length));
                    chatManager.addSystemMessage("Admin: " + adminMessage);
                    List<WebSocketClientHandler> clients = getAuthenticatedClients();
                    main.java.chat.ChatMessage msg = new main.java.chat.ChatMessage("admin", "Admin", adminMessage, "system");
                    chatManager.broadcastMessage(msg, clients);
                }
                break;
            case "clearchat":
                chatManager.clearHistory();
                break;
            case "files":
                listAvailableFiles();
                break;
            case "clearfiles":
                fileTransferManager.clearAllFiles();
                System.out.println("üóëÔ∏è Tous les fichiers ont √©t√© supprim√©s");
                break;
            case "users":
                listConnectedUsers();
                break;
            case "refreshusers":
                broadcastUserList();
                System.out.println("üîÑ Liste des utilisateurs diffus√©e manuellement");
                break;
            case "stop":
                stop();
                break;
            case "help":
                printHelp();
                break;
            default:
                printHelp();
        }
    }

    private void listAvailableFiles() {
        List<FileInfo> files = fileTransferManager.getAvailableFiles();
        System.out.println("\nüìÅ FICHIERS DISPONIBLES");
        System.out.println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");

        if (files.isEmpty()) {
            System.out.println("Aucun fichier disponible");
        } else {
            for (FileInfo file : files) {
                System.out.println("üìÑ " + file.getName());
                System.out.println("   Taille: " + formatFileSize(file.getSize()));
                System.out.println("   Type: " + file.getType());
                System.out.println();
            }
        }
    }

    private String formatFileSize(long bytes) {
        if (bytes < 1024) return bytes + " B";
        if (bytes < 1024 * 1024) return (bytes / 1024) + " KB";
        return (bytes / (1024 * 1024)) + " MB";
    }

    // ‚úÖ AM√âLIORATION : Liste des utilisateurs avec plus de d√©tails
    private void listConnectedUsers() {
        System.out.println("\nüë• UTILISATEURS CONNECT√âS");
        System.out.println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");

        List<WebSocketClientHandler> authenticatedClients = getAuthenticatedClients();
        if (authenticatedClients.isEmpty()) {
            System.out.println("Aucun utilisateur connect√©");
        } else {
            for (WebSocketClientHandler client : authenticatedClients) {
                String clientId = client.getClientId();
                String displayName = clientDisplayNames.getOrDefault(clientId, "User-" + clientId.substring(0, 4));
                String controlStatus = controlQueue.hasControl(clientId) ? "üéÆ Contr√¥le" : "üëÄ Spectateur";
                String password = authManager.getClientPassword(clientId);

                System.out.println("üîó " + displayName);
                System.out.println("   ID: " + clientId);
                System.out.println("   IP: " + client.getClientIP());
                System.out.println("   R√¥le: " + controlStatus);
                System.out.println("   üîë Mot de passe: " + (password != null ? password : "N/A"));

                if (controlQueue.hasControl(clientId)) {
                    long remainingTime = controlQueue.getRemainingControlTime();
                    System.out.println("   ‚è±Ô∏è Temps restant: " + (remainingTime/1000) + "s");
                } else {
                    int position = controlQueue.getQueuePosition(clientId);
                    if (position > 0) {
                        System.out.println("   üìç Position file: " + position);
                    }
                }
                System.out.println();
            }

            // ‚úÖ NOUVEAU : Afficher le total
            System.out.println("üìä Total: " + authenticatedClients.size() + " utilisateur(s) connect√©(s)");
        }
    }

    private void printHelp() {
        System.out.println("\nüìö COMMANDES DISPONIBLES");
        System.out.println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        System.out.println("list              - Lister les demandes de connexion");
        System.out.println("accept <ID>       - Accepter une connexion");
        System.out.println("deny <ID>         - Refuser une connexion");
        System.out.println("passwords         - Lister tous les mots de passe actifs");
        System.out.println("getpassword <ID>  - Obtenir le mot de passe d'un client");
        System.out.println("regenerate <ID>   - R√©g√©n√©rer le mot de passe d'un client");
        System.out.println("closesession <ID> - Fermer la session d'un client sp√©cifique");
        System.out.println("status            - Afficher l'√©tat de la concurrence"); // ‚úÖ NOUVEAU
        System.out.println("forcerelease      - Lib√©rer le contr√¥le de force"); // ‚úÖ NOUVEAU
        System.out.println("queue             - Voir la file d'attente"); // ‚úÖ NOUVEAU
        System.out.println("chat <message>    - Envoyer un message admin");
        System.out.println("clearchat         - Effacer l'historique du chat");
        System.out.println("files             - Lister les fichiers disponibles");
        System.out.println("clearfiles        - Supprimer tous les fichiers");
        System.out.println("users             - Lister les utilisateurs connect√©s");
        System.out.println("refreshusers      - Diffuser manuellement la liste des utilisateurs");
        System.out.println("stop              - Arr√™ter le serveur");
        System.out.println("help              - Afficher cette aide");
        System.out.println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
    }

    private void printStartupInfo() {
        System.out.println("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
        System.out.println("‚ïë       üöÄ SERVEUR PARTAGE D'√âCRAN        ‚ïë");
        System.out.println("‚ïë    AVEC CHAT ET TRANSFERT FICHIERS      ‚ïë");
        System.out.println("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£");
        System.out.println("‚ïë WebSocket: 8081                         ‚ïë");
        System.out.println("‚ïë Frontend React: Port 3000               ‚ïë");
        System.out.println("‚ïë üîë Mots de passe: G√©n√©r√©s automatiquement ‚ïë");
        System.out.println("‚ïë Chat: Noms d'affichage personnalis√©s     ‚ïë");
        System.out.println("‚ïë Fichiers: Upload/Download jusqu'√† 50MB   ‚ïë");
        System.out.println("‚ïë üë• Liste utilisateurs: Temps r√©el       ‚ïë");
        System.out.println("‚ïë ‚è±Ô∏è Contr√¥le limit√©: 4 minutes           ‚ïë");
        System.out.println("‚ïë üò¥ Timeout inactivit√©: 1 minute         ‚ïë");
        System.out.println("‚ïë Optimis√©: 8-10 FPS pour fluidit√©        ‚ïë");
        System.out.println("‚ïë                                          ‚ïë");
        System.out.println("‚ïë üí¨ COMMANDES PRINCIPALES:               ‚ïë");
        System.out.println("‚ïë ‚Ä¢ list - Voir demandes de connexion     ‚ïë");
        System.out.println("‚ïë ‚Ä¢ accept <ID> - Accepter une connexion  ‚ïë");
        System.out.println("‚ïë ‚Ä¢ status - √âtat de la concurrence       ‚ïë");
        System.out.println("‚ïë ‚Ä¢ users - Voir utilisateurs connect√©s   ‚ïë");
        System.out.println("‚ïë ‚Ä¢ help - Aide compl√®te                  ‚ïë");
        System.out.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
    }

    private List<WebSocketClientHandler> getAuthenticatedClients() {
        return clients.stream()
                .filter(client -> authManager.isAuthenticated(client.getClientId()))
                .collect(Collectors.toList());
    }

    public String requestConnection(String clientIP, WebSocketClientHandler handler) {
        return authManager.createConnectionRequest(clientIP, handler);
    }

    public boolean authenticatePassword(String clientId, String password) {
        return authManager.authenticatePassword(clientId, password);
    }

    // ‚úÖ MODIFICATION : Authentification avec diffusion de liste
    public void authenticateClient(String clientId, String clientIP, String displayName) {
        authManager.addAuthenticatedClient(clientId, clientIP);
        clientDisplayNames.put(clientId, displayName);

        // ‚úÖ NOUVEAU : Enregistrer le nom dans ControlQueue
        controlQueue.setClientName(clientId, displayName);

        for (WebSocketClientHandler client : clients) {
            if (client.getClientId().equals(clientId)) {
                sendChatHistoryToClient(client);
                sendUserListToClient(client);
                break;
            }
        }

        notifyUserJoined(clientId, displayName);
    }

    public void authenticateClient(String clientId, String clientIP) {
        authenticateClient(clientId, clientIP, "User-" + clientId.substring(0, 4));
    }

    // ‚úÖ MODIFICATION : Contr√¥le avec diffusion de liste
    public boolean requestControl(String clientId) {
        boolean granted = controlQueue.requestControl(clientId);

        // ‚úÖ NOUVEAU : Diffuser la liste mise √† jour quand le contr√¥le change
        if (granted) {
            broadcastUserList();
        }

        return granted;
    }

    // ‚úÖ MODIFICATION : Lib√©ration de contr√¥le avec diffusion de liste
    public void releaseControl(String clientId) {
        controlQueue.releaseControl(clientId);

        // ‚úÖ NOUVEAU : Diffuser la liste mise √† jour
        broadcastUserList();
    }

    public boolean hasControl(String clientId) {
        return controlQueue.hasControl(clientId);
    }

    // ‚úÖ MODIFICATION : Suppression de client avec diffusion de liste
    public void removeClient(WebSocketClientHandler client) {
        String clientId = client.getClientId();

        // ‚úÖ CORRECTION : V√©rifier si le client existe avant suppression
        if (clients.contains(client)) {
            clients.remove(client);

            // Lib√©rer le contr√¥le si n√©cessaire
            if (controlQueue.hasControl(clientId)) {
                controlQueue.releaseControl(clientId);
            }

            // Nettoyer l'authentification
            if (authManager.isAuthenticated(clientId)) {
                authManager.removeClient(clientId);
                // Notifier le d√©part et diffuser la liste mise √† jour
                notifyUserLeft(clientId);
            }

            controlQueue.removeClient(clientId);

            System.out.println("üîå Client supprim√©: " + clientId);
        }
    }

    public String getClientDisplayName(String clientId) {
        return clientDisplayNames.getOrDefault(clientId, "User-" + clientId.substring(0, 4));
    }

    public void updateClientDisplayName(String clientId, String newDisplayName) {
        if (clientDisplayNames.containsKey(clientId)) {
            String oldName = clientDisplayNames.get(clientId);
            clientDisplayNames.put(clientId, newDisplayName);

            chatManager.addSystemMessage(oldName + " a chang√© son nom en " + newDisplayName);
            List<WebSocketClientHandler> clients = getAuthenticatedClients();
            main.java.chat.ChatMessage msg = new main.java.chat.ChatMessage("system", "Syst√®me",
                    oldName + " a chang√© son nom en " + newDisplayName, "system");
            chatManager.broadcastMessage(msg, clients);

            // ‚úÖ NOUVEAU : Diffuser la liste mise √† jour apr√®s changement de nom
            broadcastUserList();
        }
    }

    public void stop() {
        isRunning = false;

        screenCaptureExecutor.shutdown();
        heartbeatExecutor.shutdown();
        clientExecutor.shutdown();
        controlQueue.shutdown();

        try {
            if (serverSocket != null) serverSocket.close();
        } catch (IOException e) {
            // Ignorer
        }

        System.exit(0);
    }

    public static void main(String[] args) {
        try {
            new WebSocketServer().start();
        } catch (IOException e) {
            System.err.println("Erreur serveur: " + e.getMessage());
        }
    }
}